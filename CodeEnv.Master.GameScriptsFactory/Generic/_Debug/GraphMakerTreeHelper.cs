// --------------------------------------------------------------------------------------------------------------------
// <copyright>
// Copyright © 2012 - 2018 
//
// Email: jim@strategicforge.com
// </copyright> 
// <summary> 
// File: TreeLinkChecker.cs
// Debug tool that helps cleanup and validate ResearchTrees generated by GraphMaker's Editor Tool.
// </summary> 
// -------------------------------------------------------------------------------------------------------------------- 

////#define DEBUG_LOG
////#define DEBUG_WARN
////#define DEBUG_ERROR

// default namespace

using System.Collections.Generic;
using System.Linq;
using CodeEnv.Master.Common;
using CodeEnv.Master.GameContent;
using UnityEngine;

/// <summary>
/// Debug tool that helps cleanup and validate ResearchTrees generated by GraphMaker's Editor Tool.
/// </summary>
public class GraphMakerTreeHelper : AMonoBase {

    public string DebugName { get { return GetType().Name; } }

    [SerializeField]
    private int _expectedColumns = Constants.Zero;
    [SerializeField]
    private int _expectedRows = Constants.Zero;

    protected override void Awake() {
        base.Awake();
        __ValidateOnAwake();
    }

    /// <summary>
    /// Preliminary check that the link count is as expected.
    /// <remarks>Intended for use prior to investing time in populating node and link ID values.</remarks>
    /// </summary>
    [ContextMenu("CheckLinkCount")]
    public void CheckLinkCount() {
        int linksPerRow = _expectedRows * MyMath.Factorial(_expectedColumns - 1);
        int expectedLinkCount = _expectedRows * linksPerRow;
        var linkCount = gameObject.GetComponentsInChildren<ResearchTreeLink>().Count();
        if (expectedLinkCount != linkCount) {
            D.Warn("{0} link count {1} != expected link count {2}.", DebugName, linkCount, expectedLinkCount);
        }
        else {
            D.Log("{0} link count {1} expected.", DebugName, linkCount);
        }
    }

    /// <summary>
    /// Populates all the links with their TreeLinkIDs containing their fromNodeID and toNodeID.
    /// <remarks>Will throw an error if used after RemoveWmgContent.</remarks>
    /// </summary>
    [ContextMenu("PopulateLinkIDs")]
    public void PopulateLinkIdentifiers() {
        var allInvisibleNodes = gameObject.GetComponentsInChildren<InvisibleWmgNodeIdentifier>();
        D.AssertNotEqual(Constants.Zero, allInvisibleNodes.Count());    // Will fail if RemoveWmgContent is run first
        foreach (var iNode in allInvisibleNodes) {
            var nodeLinks = iNode.gameObject.GetComponent<WMG_Node>().links.Select(linkGo => linkGo.GetComponent<ResearchTreeLink>()).ToList();
            TreeNodeID nodeID;
            if (iNode.TryGetFromNode(out nodeID)) {
                nodeLinks.ForAll(link => link.AddFromNodeID(nodeID));
            }
            else {
                bool foundToNode = iNode.TryGetToNode(out nodeID);
                D.Assert(foundToNode);
                nodeLinks.ForAll(link => link.AddToNodeID(nodeID));
            }
        }
    }

    /// <summary>
    /// Removes unneeded content from GraphMaker, the WMG_GraphManager, all InvisibleNodes, WMG_Node and WMG_Link components.
    /// </summary>
    [ContextMenu("RemoveWmgContent")]
    public void RemoveWmgContent() {
        var wmgMgrComponent = gameObject.GetComponent<WMG_Graph_Manager>();
        if (wmgMgrComponent != null) {
            DestroyImmediate(wmgMgrComponent);
        }

        string wmgNodeSelectName = "WMG_Node_Sel";
        var wmgNodes = gameObject.GetComponentsInChildren<WMG_Node>();
        foreach (var wmgNodeComponent in wmgNodes) {
            var treeNode = wmgNodeComponent.GetComponent<AResearchTreeNode>();
            if (treeNode == null) {
                // invisible node
                D.AssertNotNull(wmgNodeComponent.gameObject.GetComponent<InvisibleWmgNodeIdentifier>());
                DestroyImmediate(wmgNodeComponent.gameObject);
            }
            else {
                var childTransforms = wmgNodeComponent.gameObject.GetComponentsInImmediateChildren<Transform>();
                var nodeSelectTransform = childTransforms.SingleOrDefault(xfrm => xfrm.name == wmgNodeSelectName);
                if (nodeSelectTransform != null) {
                    DestroyImmediate(nodeSelectTransform.gameObject);
                }
                DestroyImmediate(wmgNodeComponent);
            }
        }

        string wmgLinkSelectName = "WMG_Link_Sel";
        var wmgLinks = gameObject.GetComponentsInChildren<WMG_Link>();
        foreach (var wmgLinkComponent in wmgLinks) {
            var childTransforms = wmgLinkComponent.gameObject.GetComponentsInImmediateChildren<Transform>();
            var linkSelectTransform = childTransforms.SingleOrDefault(xfrm => xfrm.name == wmgLinkSelectName);
            if (linkSelectTransform != null) {
                DestroyImmediate(linkSelectTransform.gameObject);
            }
            var linkCollider = wmgLinkComponent.gameObject.GetComponent<Collider>();
            if (linkCollider != null) {
                DestroyImmediate(linkCollider);
            }
            DestroyImmediate(wmgLinkComponent);
        }
    }

    /// <summary>
    /// Validates all expected links are present without duplication.
    /// <remarks>Run after all LinkID values have been populated.</remarks>
    /// </summary>
    [ContextMenu("ValidateLinks")]
    public void ValidateLinks() {
        IList<TreeLinkID> linkIDsPresent = new List<TreeLinkID>();
        var allLinks = gameObject.GetComponentsInChildren<ResearchTreeLink>();
        foreach (var link in allLinks) {
            linkIDsPresent.Add(link.LinkID);
        }
        TreeLinkID duplicateLink;
        if (linkIDsPresent.ContainsDuplicates(out duplicateLink)) {
            D.Warn("{0} found duplicate {1}.", DebugName, duplicateLink.DebugName);
        }

        IList<TreeNodeID> expectedNodeIDs = new List<TreeNodeID>();
        for (int col = 1; col <= _expectedColumns; col++) {
            for (int row = 1; row <= _expectedRows; row++) {
                var nodeID = new TreeNodeID(col, row);
                expectedNodeIDs.Add(nodeID);
            }
        }

        IList<TreeNodeID> fromNodeIDs = new List<TreeNodeID>();
        IList<TreeNodeID> toNodeIDs = new List<TreeNodeID>();
        foreach (var nodeID in expectedNodeIDs) {
            if (nodeID.Column < _expectedColumns) {
                fromNodeIDs.Add(nodeID);
            }
            if (nodeID.Column > 1) {
                toNodeIDs.Add(nodeID);
            }
        }

        IList<TreeLinkID> expectedLinkIDs = new List<TreeLinkID>();
        foreach (var fromNode in fromNodeIDs) {
            foreach (var toNode in toNodeIDs) {
                if (toNode.Column > fromNode.Column) {
                    expectedLinkIDs.Add(new TreeLinkID(fromNode, toNode));
                }
            }
        }

        foreach (var expectedLinkID in expectedLinkIDs) {
            if (!linkIDsPresent.Contains(expectedLinkID)) {
                D.Warn("{0} did not find expected {1}.", DebugName, expectedLinkID.DebugName);
            }
        }
    }

    /// <summary>
    /// Renames all GameObjects including the tree name, all nodes and links and
    /// removes the UIPanel and this Helper.
    /// <remarks>Run after all NodeID and LinkID values have been populated.</remarks>
    /// </summary>
    [ContextMenu("FinalCleanup")]
    public void FinalCleanup() {
        string treeNameFormat = "RschTree_{0}x{1}";
        gameObject.name = treeNameFormat.Inject(_expectedColumns, _expectedRows);
        RenameNodes();
        RenameLinks();
        var panel = gameObject.GetComponent<UIPanel>();
        DestroyImmediate(panel);
        DestroyImmediate(this);
    }

    /// <summary>
    /// Renames the nodes.
    /// <remarks>Run after all NodeID values have been populated.</remarks>
    /// </summary>
    private void RenameNodes() {
        string nodeNameFormat = "Node_{0}_{1}";
        var treeNodes = gameObject.GetComponentsInChildren<AResearchTreeNode>();
        foreach (var node in treeNodes) {
            var nodeID = node.NodeID;
            node.gameObject.name = nodeNameFormat.Inject(nodeID.Column, nodeID.Row);
        }
    }

    /// <summary>
    /// Renames the links.
    /// <remarks>Run after all LinkID values have been populated.</remarks>
    /// </summary>
    private void RenameLinks() {
        string linkNameFormat = "Link_{0}{1}_{2}{3}";
        var treeLinks = gameObject.GetComponentsInChildren<ResearchTreeLink>();
        foreach (var link in treeLinks) {
            var linkID = link.LinkID;
            var fromNodeID = linkID.FromNodeID;
            var toNodeID = linkID.ToNodeID;
            link.gameObject.name = linkNameFormat.Inject(fromNodeID.Column, fromNodeID.Row, toNodeID.Column, toNodeID.Row);
        }
    }

    protected override void Cleanup() { }

    #region Debug

    private void __ValidateOnAwake() {
        D.AssertNotEqual(Constants.Zero, _expectedColumns);
        D.AssertNotEqual(Constants.Zero, _expectedRows);
    }

    #endregion

    public override string ToString() {
        return DebugName;
    }

}

